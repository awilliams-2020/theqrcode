generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String        @id @default(cuid())
  name          String?
  email         String        @unique
  emailVerified DateTime?
  password      String?
  image         String?
  isAdmin       Boolean       @default(false)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  deletedAt     DateTime?
  isDeleted     Boolean       @default(false)
  timezone      String        @default("UTC")
  accounts      Account[]
  apiKeys       ApiKey[]
  qrCodes       QrCode[]
  sessions      Session[]
  subscription  Subscription?
  webhooks      Webhook[]
  qrShares      QrShare[]
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model OtpToken {
  id         String   @id @default(cuid())
  email      String
  token      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  usedAt     DateTime?
  attempts   Int      @default(0)

  @@index([email, expiresAt])
  @@index([token])
}

model PasswordResetToken {
  id         String   @id @default(cuid())
  email      String
  token      String   @unique
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  usedAt     DateTime?

  @@index([email, expiresAt])
  @@index([token])
}

model EmailVerificationToken {
  id         String   @id @default(cuid())
  email      String
  token      String   @unique
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  usedAt     DateTime?

  @@index([email, expiresAt])
  @@index([token])
}

model Subscription {
  id                     String    @id @default(cuid())
  userId                 String    @unique
  stripeCustomerId       String?   @unique
  stripeSubscriptionId   String?   @unique
  stripePriceId          String?
  stripeCurrentPeriodEnd DateTime?
  plan                   String    @default("free")
  status                 String    @default("active")
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt
  trialEndsAt            DateTime?
  user                   User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model QrCode {
  id        String    @id @default(cuid())
  userId    String
  name      String
  type      String
  content   String
  shortUrl  String?   @unique
  settings  Json
  isDynamic Boolean   @default(false)
  isSandbox Boolean   @default(false) // Indicates if this QR code was created via sandbox API key
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?
  isDeleted Boolean   @default(false)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  scans     Scan[]
  shares    QrShare[]
}

model Scan {
  id        String   @id @default(cuid())
  qrCodeId  String
  ipAddress String?
  userAgent String?
  country   String?
  city      String?
  device    String?
  os        String?
  browser   String?
  referrer  String?
  scannedAt DateTime @default(now())
  qrCode    QrCode   @relation(fields: [qrCodeId], references: [id], onDelete: Cascade)
}

model QrShare {
  id          String   @id @default(cuid())
  qrCodeId    String
  userId      String
  message     String
  shareMethod String   // 'social', 'email', 'sms', 'link', 'download'
  email       String?  // For email shares
  subject     String?  // For email shares
  createdAt   DateTime @default(now())
  qrCode      QrCode   @relation(fields: [qrCodeId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([qrCodeId, createdAt])
  @@index([userId, createdAt])
}

model ApiKey {
  id          String     @id @default(cuid())
  userId      String
  name        String
  keyHash     String     @unique
  keyPrefix   String
  permissions String[]
  rateLimit   Int        @default(1000)
  environment String     @default("production") // "sandbox" or "production"
  lastUsedAt  DateTime?
  expiresAt   DateTime?
  isActive    Boolean    @default(true)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  apiUsage    ApiUsage[]
}

model ApiUsage {
  id           String   @id @default(cuid())
  apiKeyId     String
  endpoint     String
  method       String
  statusCode   Int
  responseTime Int
  ipAddress    String?
  userAgent    String?
  createdAt    DateTime @default(now())
  apiKey       ApiKey   @relation(fields: [apiKeyId], references: [id], onDelete: Cascade)

  @@index([apiKeyId, createdAt])
  @@index([createdAt])
}

model Webhook {
  id              String         @id @default(cuid())
  userId          String
  name            String
  url             String
  events          String[]
  secret          String
  isActive        Boolean        @default(true)
  lastTriggeredAt DateTime?
  failureCount    Int            @default(0)
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  user            User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  webhookEvents   WebhookEvent[]
}

model WebhookEvent {
  id           String    @id @default(cuid())
  webhookId    String
  eventType    String
  payload      Json
  status       String    @default("pending")
  responseCode Int?
  responseBody String?
  attempts     Int       @default(0)
  maxAttempts  Int       @default(3)
  nextRetryAt  DateTime?
  deliveredAt  DateTime?
  createdAt    DateTime  @default(now())
  webhook      Webhook   @relation(fields: [webhookId], references: [id], onDelete: Cascade)

  @@index([webhookId, status])
  @@index([nextRetryAt])
}

model TrialAbusePrevention {
  id        String   @id @default(cuid())
  emailHash String   @unique
  deletedAt DateTime @default(now())

  @@index([emailHash])
}

model EmailCampaign {
  id             String     @id @default(cuid())
  name           String
  subject        String
  template       String
  targetAudience String // 'all', 'free', 'starter', 'pro', 'business', 'trial_ending', 'inactive'
  status         String     @default("draft") // 'draft', 'scheduled', 'sent', 'cancelled'
  scheduledFor   DateTime?
  sentAt         DateTime?
  sentCount      Int        @default(0)
  openCount      Int        @default(0)
  clickCount     Int        @default(0)
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt
  emailLogs      EmailLog[]

  @@index([status, scheduledFor])
}

model EmailLog {
  id         String         @id @default(cuid())
  campaignId String?
  userId     String
  emailType  String // 'campaign', 'notification', 'announcement'
  subject    String
  status     String         @default("sent") // 'sent', 'opened', 'clicked', 'bounced', 'failed'
  sentAt     DateTime       @default(now())
  openedAt   DateTime?
  clickedAt  DateTime?
  campaign   EmailCampaign? @relation(fields: [campaignId], references: [id], onDelete: SetNull)

  @@index([userId, emailType])
  @@index([campaignId])
}

model Notification {
  id        String    @id @default(cuid())
  userId    String
  type      String // 'usage_alert', 'plan_limit', 'milestone', 'tip', 'update'
  title     String
  message   String
  actionUrl String?
  priority  String    @default("normal") // 'low', 'normal', 'high', 'urgent'
  isRead    Boolean   @default(false)
  readAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([userId, isRead])
  @@index([createdAt])
}

model Announcement {
  id          String             @id @default(cuid())
  title       String
  content     String
  type        String             @default("feature") // 'feature', 'update', 'maintenance', 'promotion'
  priority    String             @default("normal") // 'low', 'normal', 'high'
  targetPlans String[] // ['all'], ['free', 'starter'], etc.
  isActive    Boolean            @default(true)
  startDate   DateTime           @default(now())
  endDate     DateTime?
  ctaText     String?
  ctaUrl      String?
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  views       AnnouncementView[]

  @@index([isActive, startDate])
}

model AnnouncementView {
  id             String       @id @default(cuid())
  announcementId String
  userId         String
  viewedAt       DateTime     @default(now())
  announcement   Announcement @relation(fields: [announcementId], references: [id], onDelete: Cascade)

  @@unique([announcementId, userId])
  @@index([userId])
}

model Feedback {
  id         String   @id @default(cuid())
  userId     String
  type       String // 'bug', 'feature', 'improvement', 'general'
  category   String? // 'usability', 'performance', 'design', 'functionality'
  rating     Int? // 1-5 stars
  subject    String
  message    String
  page       String? // URL where feedback was submitted
  status     String   @default("new") // 'new', 'reviewing', 'planned', 'completed', 'declined'
  priority   String   @default("normal") // 'low', 'normal', 'high'
  adminNotes String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([userId, createdAt])
  @@index([status, priority])
}

model UptimeCheck {
  id           String   @id @default(cuid())
  status       String // 'up', 'down', 'degraded'
  responseTime Int? // in milliseconds
  statusCode   Int?
  errorMessage String?
  checkedAt    DateTime @default(now())

  @@index([checkedAt])
  @@index([status, checkedAt])
}

model DowntimeIncident {
  id            String    @id @default(cuid())
  startedAt     DateTime  @default(now())
  endedAt       DateTime?
  duration      Int? // in seconds, calculated when incident ends
  cause         String? // 'server_error', 'database_error', 'timeout', 'unknown'
  affectedPaths String[] // which endpoints/paths were affected
  resolved      Boolean   @default(false)
  notes         String?

  @@index([startedAt])
  @@index([resolved, startedAt])
}
